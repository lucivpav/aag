#!/usr/bin/env ruby

require 'trollop'
require 'ostruct'

class FA
  def initialize(input)
    @n = Hash.new
    @t = Array.new
    @d = Hash.new {|h,k| h[k] = Array.new }
    @s = String.new
    @f = Hash.new

    input = File.new(input)
    line = input.readline.split
    line[1..-1].each {|i| @t << i}

    input.each_line do |x|
      x = x.split

      state = x[0].gsub(/[<>]/, "");
      @n[state] = nil
      if x[0].include? ">"
        @s = state
      end
      if x[0].include? "<"
        @f[state] = nil
      end

      x[1..-1].each_with_index do |x, i|
        to = Hash.new
        if x != "-"
          x.split(/\|/).each { |x| to[x] = nil }
        end
        @d[state] << to
      end
    end
  end

  def to_s
    output = "NFA"
    @t.each { |x| output += " #{x}" }
    @n.each_key do |x|
      output += "\n"
      output += ">" if x == @s
      output += "<" if @f.key?(x)
      output += x
      @d[x].each do |x|
        output += " "
        first = true
        x.each_key do |x| 
          output += "|" if !first 
          output += x 
          first = false if first
        end
        output += "-" if x.empty?
      end
    end
    output
  end

  def eps_closure_state(n)
    @visited[n] = nil
    @d[n][-1].each_key do |x|
      eps_closure_state(x) if !@visited.key?(x)
    end
  end

  def eps_closure
    closure = Hash.new {|h,k| h[k] = OpenStruct.new}
    @n.each_key do |x|
      @visited = Hash.new
      eps_closure_state(x)
      closure[x].to = Array.new
      closure[x].start = x == @s
      closure[x].final = false
      @visited.each_key {|y| closure[x].to << y}
      @visited.each_key do |y|
        closure[x].final = true if @f.key?(y)
      end
    end
    closure
  end

  def eps_closure_print
    output = String.new
    eps_closure.each do |state,x|
      output += ">" if x.start
      output += "<" if x.final
      output += state + ": " + x.to.join("|") + "\n"
    end
    output
  end

  def remove_eps
    closure = eps_closure
    @n.each_key {|x| @d[x].pop}
    @t.pop # TODO: eps may not be the last transition
    
    @n.each_key do |x|
      @f[x] = nil if closure[x].final
    end

    @n.each_key do |x|
      closure[x].to.each do |y|
        @d[y].each_with_index do |z,i|
          z.each_key do |k|
            @d[x][i][k]=nil
          end
        end
      end
    end
    self
  end

  def useless?(n)
    @visited[n] = nil
    return false if @f.key?(n)
    @d[n].each do |x|
      x.each_key do |y|
        useless = true
        useless = useless?(y) if !@visited.key?(y)
        return false if !useless
      end
    end
    return true
  end

  def remove_useless
    useless = Hash.new
    @n.each_key do |x|
      @visited = Hash.new
      useless[x] = nil if useless?(x)
    end
    useless.each_key do |x|
      @n.delete(x)
    end
    self
  end

  def unreachable?(n)
    @visited[n] = nil
    return false if @s == n
    @d.each do |state,x|
      next if state == n
      found = false
      x.each do |y|
        if y.key?(n)
          found = true
          break
        end
      end
      next if !found
      unreachable = false
      unreachable = unreachable?(state) if !@visited.key?(state)
      return false if !unreachable
    end
    return true
  end

  def remove_unreachable
    unreachable = Hash.new
    @n.each_key do |x|
      @visited = Hash.new
      unreachable[x] = nil if unreachable?(x)
    end
    unreachable.each_key do |x|
      @n.delete(x)
    end
    self
  end
end

opts = Trollop::options do
  opt :"eps-closure", "Compute epsilon closure"
  opt :"remove-eps", "Remove epsilon transitions"
  opt :"remove-useless", "Remove useless states"
  opt :"remove-unreachable", "Remove unreachable states"
end

if ARGV.count < 1
  puts "Usage: aag [options] input"
  exit
end

fa = FA.new(ARGV[0])
puts fa.eps_closure_print if opts[:"eps-closure"]
puts fa.remove_eps if opts[:"remove-eps"]
puts fa.remove_useless if opts[:"remove-useless"]
puts fa.remove_unreachable if opts[:"remove-unreachable"]
